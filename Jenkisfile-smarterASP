pipeline {
  agent { label 'win-agent-1' }

  parameters {
    string(name: 'CONFIGURATION', defaultValue: 'Release', description: 'Build configuration (Debug/Release)')
    choice(name:  'DEPLOY_METHOD', choices: ['WEBDEPLOY','FTP'], description: 'Choose deployment method')

    // Web Deploy (from SmarterASP.NET control panel → VS WebDeploy)
    string(name: 'SITE_NAME', defaultValue: 'your-site-name', description: 'Web Deploy - IIS Site name in control panel')
    string(name: 'WD_SERVER', defaultValue: 'webdeploy.smarterasp.net', description: 'Web Deploy - Web Deploy server host')
    string(name: 'WD_PORT',   defaultValue: '8172', description: 'Web Deploy - Web Deploy port (usually 8172)')

    // FTP fallback
    string(name: 'FTP_HOST',  defaultValue: 'ftp.smarterasp.net', description: 'FTP - FTP host')
    string(name: 'FTP_PATH',  defaultValue: '/wwwroot', description: 'FTP - Target folder for upload')
  }

  environment {
    DOTNET_SKIP_FIRST_TIME_EXPERIENCE = '1'
    DOTNET_NOLOGO = '1'
    PUBLISH_DIR = "${env.WORKSPACE}\\publish"
    MSDEPLOY_EXE = 'C:\\Program Files\\IIS\\Microsoft Web Deploy V3\\msdeploy.exe'

    // Secret Text credentials (create these 4 IDs in Jenkins > Credentials)
    WD_USER = credentials('WD_USERNAME')
    WD_PASS = credentials('WD_PASSWORD')
    FTP_USER = credentials('FTP_USERNAME')
    FTP_PASS = credentials('FTP_PASSWORD')
  }

  stages {
    stage('Restore & Build') {
      steps {
        bat '''
          @echo on
          where dotnet || (echo ERROR: .NET SDK not found & exit /b 1)

          for /f "usebackq delims=" %%f in (`powershell -NoP -C "(Get-ChildItem -Recurse -Filter *.csproj | Select-Object -First 1).FullName"`) do (
            echo %%f > project.path
          )
          if not exist project.path (
            echo ERROR: No .csproj found
            exit /b 1
          )
          set /p CSPROJ=<project.path
          echo Found project: %CSPROJ%

          dotnet restore "%CSPROJ%"
          dotnet build   "%CSPROJ%" -c "%CONFIGURATION%"
        '''
      }
    }

    stage('Publish (Release folder)') {
      steps {
        bat '''
          @echo on
          if not exist project.path (
            echo ERROR: project.path not found - build stage failed or was skipped
            exit /b 1
          )
          set /p CSPROJ=<project.path

          if exist "%PUBLISH_DIR%" rmdir /s /q "%PUBLISH_DIR%"
          mkdir "%PUBLISH_DIR%"

          dotnet publish "%CSPROJ%" -c "%CONFIGURATION%" -o "%PUBLISH_DIR%" --no-build
          if %ERRORLEVEL% NEQ 0 exit /b %ERRORLEVEL%
          dir "%PUBLISH_DIR%"
        '''
        stash name: 'published', includes: 'publish/**'
      }
    }

    stage('Deploy (WebDeploy)') {
      when { expression { params.DEPLOY_METHOD == 'WEBDEPLOY' } }
      steps {
        unstash 'published'
        powershell '''
          $ErrorActionPreference = "Stop"

          $pub    = "$env:PUBLISH_DIR"
          if (-not (Test-Path $pub)) { throw "Publish dir not found: $pub" }

          $msdeploy = "$env:MSDEPLOY_EXE"
          if (-not (Test-Path $msdeploy)) { throw "msdeploy.exe not found at $msdeploy" }

          $site   = "$env:SITE_NAME"
          $server = "$env:WD_SERVER"
          $port   = "$env:WD_PORT"
          $user   = "$env:WD_USER"
          $pass   = "$env:WD_PASS"

          $src  = "-source:contentPath=$pub"
          $dest = "-dest:contentPath=$site,ComputerName=https://$server`:$port/msdeploy.axd?site=$site,UserName=$user,Password=$pass,AuthType=Basic,includeAcls=False"

          $skip1 = '-skip:objectName=filePath,absolutePath=.*\\\\aspnetcorev2_inprocess\\.dll'
          $skip2 = '-skip:objectName=dirPath,absolutePath=.*\\\\\\.well-known(\\\\.*)?'

          & "$msdeploy" `
            $src `
            $dest `
            -allowUntrusted `
            -verb:sync `
            -retryAttempts:5 -retryInterval:3000 `
            -enableRule:AppOffline `
            -disableLink:AppPoolExtension `
            -disableLink:ContentExtension `
            -disableLink:CertificateExtension `
            -enableRule:DoNotDeleteRule `
            $skip1 `
            $skip2
        '''
      }
    }



    stage('Deploy (FTP/FTPS)') {
      when { expression { params.DEPLOY_METHOD == 'FTP' } }
      steps {
        unstash 'published'
        powershell '''
          $ErrorActionPreference = "Stop"

          $pub = "$env:PUBLISH_DIR"
          if (-not (Test-Path $pub)) { throw "Publish dir not found: $pub" }

          $ftpRoot = "ftp://$($env:FTP_HOST)$($env:FTP_PATH.TrimEnd('/'))/"
          $creds   = New-Object System.Net.NetworkCredential($env:FTP_USER, $env:FTP_PASS)

          function Ensure-FtpFolder {
            param([string]$FullPath)
            $parts = $FullPath.Trim('/').Split('/') | Where-Object { $_ -ne '' }
            $built = ""
            foreach ($p in $parts) {
              $built = if ($built) { "$built/$p" } else { $p }
              $mk = [System.Net.FtpWebRequest]::Create($ftpRoot + $built)
              $mk.Method = [System.Net.WebRequestMethods+Ftp]::MakeDirectory
              $mk.Credentials = $creds
              try { $mk.GetResponse().Close() } catch { } # ignore if exists
            }
          }

          Get-ChildItem -Path $pub -Recurse -File | ForEach-Object {
            $rel = $_.FullName.Substring($pub.Length).TrimStart('\').Replace('\','/')
            $dir = Split-Path $rel -Parent
            if ($dir) { Ensure-FtpFolder -FullPath $dir }

            $uri = [System.Uri]::new($ftpRoot + $rel)
            $req = [System.Net.FtpWebRequest]::Create($uri)
            $req.Method = [System.Net.WebRequestMethods+Ftp]::UploadFile
            $req.Credentials = $creds
            $req.UseBinary = $true
            $bytes = [System.IO.File]::ReadAllBytes($_.FullName)
            $stream = $req.GetRequestStream()
            $stream.Write($bytes, 0, $bytes.Length)
            $stream.Close()
            $res = $req.GetResponse(); $res.Close()
          }
        '''
      }
    }
  }

  post {
    success { echo '✅ Build, publish, and deployment completed successfully.' }
    failure { echo '❌ Pipeline failed. See error logs above.' }
  }
}
