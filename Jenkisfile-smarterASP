pipeline {
  agent { label 'win-dev' } 
  options { disableConcurrentBuilds(); timestamps(); ansiColor('xterm') }

  parameters {
    string(name: 'CONFIGURATION', defaultValue: 'Release', description: 'Build configuration (Debug/Release)')
    string(name: 'SMOKE_URLS',    defaultValue: '/,/swagger', description: 'Comma-separated paths to test locally')
    choice(name:  'DEPLOY_METHOD', choices: ['WEBDEPLOY','FTP'], description: 'Choose deployment method')

    // Web Deploy (from SmarterASP.NET control panel → VS WebDeploy)
    string(name: 'SITE_NAME', defaultValue: 'your-site-name', description: 'IIS Site name in control panel')
    string(name: 'WD_SERVER', defaultValue: 'webdeploy.smarterasp.net', description: 'Web Deploy server host')
    string(name: 'WD_PORT',   defaultValue: '8172', description: 'Web Deploy port (usually 8172)')

    // FTP fallback
    string(name: 'FTP_HOST',  defaultValue: 'ftp.smarterasp.net', description: 'FTP host')
    string(name: 'FTP_PATH',  defaultValue: '/wwwroot', description: 'Target folder for upload')

    // Local smoke-test base URL
    string(name: 'SMOKE_BASE_URL', defaultValue: 'http://localhost:5005', description: 'Target base URL (localhost or EC2 DNS)')
  }

  environment {
    DOTNET_SKIP_FIRST_TIME_EXPERIENCE = '1'
    DOTNET_NOLOGO = '1'
    // Do NOT override WORKSPACE; Jenkins sets it.
    PUBLISH_DIR = "${env.WORKSPACE}\\publish"
    MSDEPLOY_EXE = 'C:\\Program Files\\IIS\\Microsoft Web Deploy V3\\msdeploy.exe'
  }

  stages {
    // SCM checkout handled by jobs SCM config

    stage('Restore & Build') {
      steps {
        bat '''
          @echo on
          where dotnet || (echo ERROR: .NET SDK not found & exit /b 1)

          for /f "usebackq delims=" %%f in (`powershell -NoP -C "(Get-ChildItem -Recurse -Filter *.csproj | Select-Object -First 1).FullName"`) do (
            echo %%f > project.path
          )
          if not exist project.path (
            echo ERROR: No .csproj found
            exit /b 1
          )
          set /p CSPROJ=<project.path
          echo Found project: %CSPROJ%

          dotnet restore "%CSPROJ%"
          dotnet build   "%CSPROJ%" -c "%CONFIGURATION%"
        '''
      }
    }

    stage('Publish (Release folder)') {
      steps {
        bat '''
          if not exist project.path (
            echo ERROR: project.path not found - build stage failed or was skipped
            exit /b 1
          )
          set /p CSPROJ=<project.path

          if exist "%PUBLISH_DIR%" rmdir /s /q "%PUBLISH_DIR%"
          mkdir "%PUBLISH_DIR%"

          dotnet publish "%CSPROJ%" -c "%CONFIGURATION%" -o "%PUBLISH_DIR%" --no-build
          if %ERRORLEVEL% NEQ 0 exit /b %ERRORLEVEL%
          dir "%PUBLISH_DIR%"
        '''
        stash name: 'published', includes: 'publish/**'
      }
    }

    stage('Run API locally (5005)') {
        steps {
            powershell '''
            $ErrorActionPreference = "Stop"

            # Paths
            $repo     = Join-Path $env:WORKSPACE 'repo'
            $apiProj  = Get-ChildItem -Path $repo -Recurse -Filter *.csproj | Where-Object { $_.DirectoryName -match '\\api(\\|$)' } | Select-Object -First 1
            if (-not $apiProj) { throw "Could not find API .csproj under repo\\api" }

            # Make sure port 5005 is free
            $pid = (Get-NetTCPConnection -LocalPort 5005 -ErrorAction SilentlyContinue | Select-Object -First 1).OwningProcess
            if ($pid) { Write-Host "Port 5005 in use by PID $pid. Killing..."; Stop-Process -Id $pid -Force }

            # Build & publish self-contained
            $pub = Join-Path $env:WORKSPACE 'publish'
            dotnet publish "`"$($apiProj.FullName)`"" -c Release -o "`"$pub`""

            # Start API with Kestrel on port 5005
            $env:ASPNETCORE_URLS = "http://0.0.0.0:5005"
            $exe = Get-ChildItem $pub -Filter *.dll | Where-Object { $_.Name -notlike '*test*' } | Select-Object -First 1
            if (-not $exe) { throw "No API DLL found in $pub" }

            # Launch detached
            $log = Join-Path $env:WORKSPACE 'api-stdout.log'
            $err = Join-Path $env:WORKSPACE 'api-stderr.log'
            Start-Process -FilePath "dotnet" -ArgumentList "`"$($exe.FullName)`"" -WorkingDirectory $pub -RedirectStandardOutput $log -RedirectStandardError $err

            # Wait until ready (probe /health, /swagger, and /)
            $base = "http://localhost:5005"
            $paths = @("/health","/swagger","/")
            $deadline = (Get-Date).AddMinutes(3)
            $ready = $false
            while ((Get-Date) -lt $deadline -and -not $ready) {
                foreach ($p in $paths) {
                try {
                    $r = Invoke-WebRequest -Uri ($base + $p) -UseBasicParsing -TimeoutSec 3
                    if ($r.StatusCode -ge 200 -and $r.StatusCode -lt 500) {
                    Write-Host "API responded on $base$p with $($r.StatusCode)"
                    $ready = $true; break
                    }
                } catch {}
                }
                if (-not $ready) { Start-Sleep -Seconds 2 }
            }
            if (-not $ready) {
                Write-Host "---- Last 100 lines of API logs (stdout) ----"
                if (Test-Path $log) { Get-Content $log -Tail 100 | Write-Output }
                Write-Host "---- Last 100 lines of API logs (stderr) ----"
                if (Test-Path $err) { Get-Content $err -Tail 100 | Write-Output }
                throw "API failed to become ready on $base within 3 minutes."
            }

            Write-Host "✅ API is up at $base"
            '''
        }
    }


    stage('Smoke-test (Postman/Newman)') {
        steps {
            powershell '''
            $ErrorActionPreference = "Stop"

            # Paths (your repo is checked out to ...\\workspace\\coreapi)
            $repo        = Join-Path $env:WORKSPACE ''
            $collection  = Join-Path $repo 'tests\\postman\\smoke.collection.json'
            $envFile     = Join-Path $repo 'tests\\postman\\local.env.json'

            if (-not (Test-Path $collection)) { throw "Collection not found: $collection" }

            # Ensure Chocolatey (one-time)
            if (-not (Get-Command choco -ErrorAction SilentlyContinue)) {
                Set-ExecutionPolicy Bypass -Scope Process -Force
                [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
                Invoke-Expression ((New-Object Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
            }

            # Ensure Node.js (one-time)
            if (-not (Get-Command node -ErrorAction SilentlyContinue)) {
                choco install nodejs-lts -y --no-progress
                refreshenv | Out-Null
            }

            # Wait until API is ready
            $baseUrl = "${env:SMOKE_BASE_URL}"
            Write-Host "Waiting for API at $baseUrl ..."
            $deadline = (Get-Date).AddMinutes(2)
            $ok = $false
            while ((Get-Date) -lt $deadline) {
                try {
                $r = Invoke-WebRequest -Uri ($baseUrl.TrimEnd('/') + '/health') -UseBasicParsing -TimeoutSec 3
                if ($r.StatusCode -eq 200) { $ok = $true; break }
                } catch { Start-Sleep -Seconds 2 }
            }
            if (-not $ok) { throw "API did not become ready at $baseUrl within 2 minutes." }

            # Build Newman args without ternary
            $envArg = ""
            if (Test-Path $envFile) {
                $envArg = "--environment `"$envFile`""
            }

            # Reports
            $outDir = Join-Path $env:WORKSPACE 'newman-reports'
            New-Item -ItemType Directory -Force -Path $outDir | Out-Null
            $junit = Join-Path $outDir 'smoke-junit.xml'

            # Prefer runtime BASE_URL
            $env:BASE_URL = $baseUrl

            # Run Newman (via npx)
            npx newman run "`"$collection`"" `
                $envArg `
                --reporters cli,junit `
                --reporter-junit-export "`"$junit`"" `
                --timeout-request 5000 `
                --delay-request 100 `
                --bail

            Write-Host "✅ Newman smoke tests passed against $baseUrl"
            '''
        }
        post {
            always {
            junit allowEmptyResults: true, testResults: 'newman-reports/*.xml'
            archiveArtifacts artifacts: 'newman-reports/**', onlyIfSuccessful: false
            }
        }
    }

    
}

  post {
    success { echo '✅ Build, smoke-test, and deployment completed successfully.' }
    failure { echo '❌ Pipeline failed. See error logs above.' }
  }
}
