pipeline {
  agent { label 'win-dev' } 
  options { disableConcurrentBuilds(); timestamps(); ansiColor('xterm') }

  parameters {
    string(name: 'CONFIGURATION', defaultValue: 'Release', description: 'Build configuration (Debug/Release)')
    string(name: 'SMOKE_URLS',    defaultValue: '/,/swagger', description: 'Comma-separated paths to test locally')
    choice(name:  'DEPLOY_METHOD', choices: ['WEBDEPLOY','FTP'], description: 'Choose deployment method')

    // Web Deploy (from SmarterASP.NET control panel → VS WebDeploy)
    string(name: 'SITE_NAME', defaultValue: 'your-site-name', description: 'IIS Site name in control panel')
    string(name: 'WD_SERVER', defaultValue: 'webdeploy.smarterasp.net', description: 'Web Deploy server host')
    string(name: 'WD_PORT',   defaultValue: '8172', description: 'Web Deploy port (usually 8172)')

    // FTP fallback
    string(name: 'FTP_HOST',  defaultValue: 'ftp.smarterasp.net', description: 'FTP host')
    string(name: 'FTP_PATH',  defaultValue: '/wwwroot', description: 'Target folder for upload')

    // Local smoke-test base URL
    string(name: 'SMOKE_BASE_URL', defaultValue: 'http://localhost:5005', description: 'Target base URL (localhost or EC2 DNS)')
  }

  environment {
    DOTNET_SKIP_FIRST_TIME_EXPERIENCE = '1'
    DOTNET_NOLOGO = '1'
    // Do NOT override WORKSPACE; Jenkins sets it.
    PUBLISH_DIR = "${env.WORKSPACE}\\publish"
    MSDEPLOY_EXE = 'C:\\Program Files\\IIS\\Microsoft Web Deploy V3\\msdeploy.exe'
  }

  stages {
    // SCM checkout handled by jobs SCM config

    stage('Restore & Build') {
      steps {
        bat '''
          @echo on
          where dotnet || (echo ERROR: .NET SDK not found & exit /b 1)

          for /f "usebackq delims=" %%f in (`powershell -NoP -C "(Get-ChildItem -Recurse -Filter *.csproj | Select-Object -First 1).FullName"`) do (
            echo %%f > project.path
          )
          if not exist project.path (
            echo ERROR: No .csproj found
            exit /b 1
          )
          set /p CSPROJ=<project.path
          echo Found project: %CSPROJ%

          dotnet restore "%CSPROJ%"
          dotnet build   "%CSPROJ%" -c "%CONFIGURATION%"
        '''
      }
    }

    stage('Publish (Release folder)') {
      steps {
        bat '''
          if not exist project.path (
            echo ERROR: project.path not found - build stage failed or was skipped
            exit /b 1
          )
          set /p CSPROJ=<project.path

          if exist "%PUBLISH_DIR%" rmdir /s /q "%PUBLISH_DIR%"
          mkdir "%PUBLISH_DIR%"

          dotnet publish "%CSPROJ%" -c "%CONFIGURATION%" -o "%PUBLISH_DIR%" --no-build
          if %ERRORLEVEL% NEQ 0 exit /b %ERRORLEVEL%
          dir "%PUBLISH_DIR%"
        '''
        stash name: 'published', includes: 'publish/**'
      }
    }

    stage('Smoke-test (Postman/Newman)') {
        steps {
            powershell '''
            $ErrorActionPreference = "Stop"

            # Paths
            $repo        = Join-Path $env:WORKSPACE 'repo'
            $collection  = Join-Path $repo 'tests\\postman\\smoke.collection.json'
            $envFile     = Join-Path $repo 'tests\\postman\\local.env.json'
            if (-not (Test-Path $collection)) { throw "Collection not found: $collection" }

            # Ensure Chocolatey (one-time)
            if (-not (Get-Command choco -ErrorAction SilentlyContinue)) {
                Set-ExecutionPolicy Bypass -Scope Process -Force
                [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
                Invoke-Expression ((New-Object Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
            }

            # Ensure Node (one-time)
            if (-not (Get-Command node -ErrorAction SilentlyContinue)) {
                choco install nodejs-lts -y --no-progress
                refreshenv | Out-Null
            }

            # Wait until API is actually up before running tests (fast retry loop)
            $baseUrl = "${env:SMOKE_BASE_URL}"
            Write-Host "Waiting for API at $baseUrl ..."
            $deadline = (Get-Date).AddMinutes(2)
            $ok = $false
            while ((Get-Date) -lt $deadline) {
                try {
                $r = Invoke-WebRequest -Uri ($baseUrl.TrimEnd('/') + '/health') -UseBasicParsing -TimeoutSec 3
                if ($r.StatusCode -eq 200) { $ok = $true; break }
                } catch { Start-Sleep -Seconds 2 }
            }
            if (-not $ok) { throw "API did not become ready at $baseUrl within 2 minutes." }

            # Newman run
            $outDir = Join-Path $env:WORKSPACE 'newman-reports'
            New-Item -ItemType Directory -Force -Path $outDir | Out-Null
            $junit = Join-Path $outDir 'smoke-junit.xml'

            $envArg = (Test-Path $envFile) ? "--environment `"$envFile`"" : ""
            $env:BASE_URL = $baseUrl  # available to collection if you reference {{BASE_URL}}

            npx newman run "`"$collection`"" `
                $envArg `
                --reporters cli,junit `
                --reporter-junit-export "`"$junit`"" `
                --timeout-request 5000 `
                --delay-request 100 `
                --bail

            Write-Host "✅ Newman smoke tests passed against $baseUrl"
            '''
        }
        post {
            always {
            junit allowEmptyResults: true, testResults: 'newman-reports/*.xml'
            archiveArtifacts artifacts: 'newman-reports/**', onlyIfSuccessful: false
            }
        }
    }

    
}

  post {
    success { echo '✅ Build, smoke-test, and deployment completed successfully.' }
    failure { echo '❌ Pipeline failed. See error logs above.' }
  }
}
